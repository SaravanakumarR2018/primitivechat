name: Integration Test - /addcustomer API

on:
  pull_request:
    branches:
      - main

jobs:
  integration-test:
    runs-on: ubuntu-latest
    container:
      image: docker:20.10.7  # Use a Docker image that includes Docker CLI
      options: --privileged

    env:
      PR_BRANCH: ${{ github.head_ref }}
      COMMIT_SHA: ${{ github.sha }}
      GITHUB_REPOSITORY: ${{ github.repository }}
      PR_NUMBER: ${{ github.event.pull_request.number}}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Install Docker Compose
        run: |
          apk add --no-cache curl \
          && curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose \
          && chmod +x /usr/local/bin/docker-compose

      - name: Run Server
        run: |
          echo "Starting the server..."
          chmod +x ./build/run_server.sh
          ./build/run_server.sh
          echo "Server has been started."
          docker ps -a
          # List all running containers with their ports
          echo "Listing running containers and their exposed ports:"
          docker ps --format "table {{.ID}}\t{{.Names}}\t{{.Ports}}"
          grep -qE '(docker|lxc)' /proc/1/cgroup && echo "Inside Docker" || echo "Not inside Docker"
          # Display the hostname (usually set to container ID in Docker)
          echo "Container ID (hostname): $(hostname)"
          # Get the container IP and store it in a variable
          CONTAINER_IP=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' chat_service)
          # Echo the container IP to verify
          echo "Container IP is: $CONTAINER_IP"
          # Construct the curl command and echo it
          CURL_CMD="curl -s http://$CONTAINER_IP:8000/"
          echo "Running command: $CURL_CMD"
          # Execute the curl command
          eval $CURL_CMD
      

      - name: Wait for server to be ready
        run: |
          docker ps -a
          echo "Waiting for the server to be ready..."
          remaining_time=60  # Set the total wait time in seconds (e.g., 60 seconds)
          while [ $remaining_time -gt 0 ]; do
            if curl -s http://localhost:8000/ | grep -q "The server is up and running!"; then
              echo "Server is now ready."
              break
            fi
            echo "Waiting for server to start... Remaining wait time: $remaining_time seconds"
            sleep 5
            remaining_time=$((remaining_time - 5))  # Decrease remaining time by 5 seconds
          done
          if [ $remaining_time -le 0 ]; then
            echo "Server did not become ready in time."
            exit 1  # Exit with an error code if the server didn't start
          fi
      

      - name: Run API Integration Tests
        run: |
          echo "Running API Integration Tests..."
          docker run --network="host" -v "$(pwd)":/workspace -w /workspace python:3.10 \
          sh -c "pip install -r src/backend/lib/requirements.txt && python3 -m unittest discover -s ./test/IntegrationTests"
          echo "API Integration Tests completed."

      - name: Tear Down Server
        if: always()  # This ensures the step runs regardless of previous step outcomes
        run: |
          echo "Tearing down the server..."
          chmod +x ./build/kill_server.sh
          ./build/kill_server.sh
          echo "Server has been stopped."
