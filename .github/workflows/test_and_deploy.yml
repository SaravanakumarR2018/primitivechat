name: Deploy and Test

on:
  push:
    branches:
      - "**"  # Trigger on all branches
  pull_request:
    branches:
      - "**"  # Trigger on PR creation
  workflow_dispatch:
    inputs:
      branch:
        description: "Branch to deploy"
        required: false
        default: "main"

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 360  # 6-hour max execution time

    env:
      CHAT_SERVICE_PORT: 8000
      FRONTEND_PORT: 3000

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          ref: ${{ github.event.inputs.branch || github.head_ref || github.ref_name }}

      # Step 2: Set up SSH for GitHub
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan github.com >> ~/.ssh/known_hosts

      # Step 3: Clone the private repository using SSH
      - name: Clone the env repo using SSH
        run: |
          git clone git@github.com:SaravanakumarR2018/primitivechatenv.git env_repo
          ls -la env_repo

      # Step 4: Copy the .env file
      - name: Copy .env file
        run: |
          cp env_repo/.env.local src/frontend/.env.local
          echo "‚úÖ .env.local copied to src/frontend"

      # Step 5: Install Docker Compose
      - name: Install Docker Compose
        run: |
          sudo apt-get update
          sudo apt-get install -y docker-compose

      # Step 6: Load environment variables from .env file
      - name: Load .env and verify
        working-directory: src/backend
        run: |
          echo "Loading .env file..."
          if [ ! -f .env ]; then
            echo "Error: .env file not found in $(pwd)"
            exit 1
          fi
          # Export all variables from .env to GitHub Actions environment and print them
          while IFS= read -r line || [ -n "$line" ]; do
            [[ "$line" =~ ^#.*$ || -z "$line" ]] && continue  # Skip comments and empty lines
            key=$(echo "$line" | cut -d'=' -f1)
            value=$(echo "$line" | cut -d'=' -f2-)
            echo "$key=$value" >> $GITHUB_ENV
            echo "Exported: $key=$value"
          done < .env
          echo "All environment variables have been loaded and exported."

      # Step 7: Build Docker image
      - name: Build Docker image
        working-directory: src/backend  # Specify working directory here
        env:
          PROJECT_ROOT: ${{ github.workspace }}
        run: |
          echo "Building Docker image chat_service_image"
          docker build -t chat_service_image:latest -f ${PROJECT_ROOT}/build/chat_service_docker/Dockerfile ${PROJECT_ROOT} || {
            echo "Docker build failed. Exiting..."
            exit 1
          }
          echo "Docker image chat_service_image built successfully."

      # Step 8: Run Docker Compose
      - name: Run docker-compose up
        working-directory: src/backend  # Specify working directory here
        env:
          PROJECT_ROOT: ${{ github.workspace }}
        run: docker-compose up -d

      - name: Clone Private Repo
        run: |
          git clone git@github.com:SaravanakumarR2018/primitivechatenv.git private-repo

      - name: List contents of private-repo for debugging
        run: |
          ls -la private-repo

      - name: Verify .env.local file
        run: |
          if [ -f private-repo/.env.local ]; then
            echo ".env.local file exists in private-repo"
          else
            echo ".env.local file does not exist in private-repo"
            exit 1
          fi

      - name: Move contents to src/frontend
        run: |
          cp -r private-repo/. src/frontend/

      - name: Verify .env.local file
        run: |
          if [ -f src/frontend/.env.local ]; then
            echo ".env.local file exists in src/frontend"
          else
            echo ".env.local file does not exist in src/frontend"
            exit 1
          fi

      - name: Install dependencies
        run: |
          cd src/frontend
          npm install

      - name: Build the project
        run: |
          cd src/frontend
          npm run build

      - name: Start Next.js server
        run: |
          cd src/frontend
          npm start &
          sleep 10

      - name: Wait for server to be up
        run: |
          for i in {1..18}; do
            if nc -zv localhost 3000; then
              echo "Server is listening on port 3000"
              exit 0
            else
              echo "Waiting for server to be up..."
              sleep 10
            fi
          done
          echo "Server did not start within 3 minutes"
          exit 1

      - name: Wait for Services to be Ready
        run: |
          timeout 120 bash -c '
            until curl -sSf http://localhost:${{ env.CHAT_SERVICE_PORT }} && curl -sSf http://localhost:${{ env.FRONTEND_PORT }}; 
            do 
              sleep 5; 
            done
          ' || { echo "‚ùå Services did not start in time."; exit 1; }
          echo "‚úÖ Services are up and running."

      - name: Install Loophole
        run: |
          ARCH=$(uname -m)

          if [[ "$ARCH" == "x86_64" ]]; then
            LOOPHOLE_URL="https://github.com/loophole/cli/releases/download/1.0.0-beta.15/loophole-cli_1.0.0-beta.15_linux_64bit.tar.gz"
          elif [[ "$ARCH" == "aarch64" ]]; then
            LOOPHOLE_URL="https://github.com/loophole/cli/releases/download/1.0.0-beta.15/loophole-cli_1.0.0-beta.15_linux_arm64.tar.gz"
          else
            echo "‚ùå Unsupported architecture: $ARCH"
            exit 1
          fi

          # Download and verify file exists
          curl -fsSL "$LOOPHOLE_URL" -o loophole.tar.gz

          if [[ ! -s loophole.tar.gz ]]; then
            echo "‚ùå Download failed or file is empty!"
            exit 1
          fi

          # List contents before extracting
          echo "üìÇ Archive contents:"
          tar -tzf loophole.tar.gz || (echo "‚ùå Tar extraction failed!" && exit 1)

          # Extract the archive
          mkdir -p loophole_temp
          tar -xzf loophole.tar.gz -C loophole_temp

          # Debug: List extracted files
          echo "üìÇ Extracted files:"
          ls -R loophole_temp

          # Locate the Loophole binary
          LOOPHOLE_BIN=$(find loophole_temp -type f -name "loophole" | head -n 1)

          if [[ -z "$LOOPHOLE_BIN" ]]; then
            echo "‚ùå Loophole binary not found in the extracted files!"
            exit 1
          fi

          # Move to /usr/local/bin
          sudo mv "$LOOPHOLE_BIN" /usr/local/bin/loophole
          sudo chmod +x /usr/local/bin/loophole

          # Clean up
          rm -rf loophole_temp loophole.tar.gz

          echo "‚úÖ Loophole installed successfully!"

      - name: Authenticate Loophole and Get Token
        run: |
          # Start authentication process
          AUTH_RESPONSE=$(loophole account login --json)

          # Extract access token
          ACCESS_TOKEN=eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IlQ4dGNDTmZ4ZUdRWkc5U21yWTFGZCJ9.eyJodHRwczovL2FwaS5sb29waG9sZS5jbG91ZC9lbWFpbCI6ImJoYXJhbml0aGFyYW42OTVAZ21haWwuY29tIiwiaHR0cHM6Ly9hcGkubG9vcGhvbGUuY2xvdWQvbmFtZSI6IkJoYXJhbmkgVGhhcmFuIiwiaXNzIjoiaHR0cHM6Ly9sb29waG9sZS5ldS5hdXRoMC5jb20vIiwic3ViIjoiZ29vZ2xlLW9hdXRoMnwxMTI3OTQ1NzA5Mjg0MDIxODQzOTkiLCJhdWQiOlsiaHR0cHM6Ly9hcGkubG9vcGhvbGUuY2xvdWQiLCJodHRwczovL2xvb3Bob2xlLmV1LmF1dGgwLmNvbS91c2VyaW5mbyJdLCJpYXQiOjE3NDA3NDcxMjAsImV4cCI6MTc0MDc0ODkyMCwic2NvcGUiOiJvcGVuaWQgcHJvZmlsZSBlbWFpbCBvZmZsaW5lX2FjY2VzcyIsImF6cCI6IjlvY25TQW5mSlNiNkM1MndhTDh4Y1BpZENrUmhVd0JzIiwicGVybWlzc2lvbnMiOlsidHVubmVsOmN1c3RvbS1ob3N0bmFtZSJdfQ.Wdp03lwSOGRkJ5puEC1MkmSFoEpEBjOJ22QBm2etJ8bwbdyLrtrnn6BFDL5aTFOW341Hch9HwWcjvMly585xMSZ0YgrJ1nvrEvM5kPz9JdWjt6-iTTzSEazm2JQQrN0PWwu3R3A8FLGe7HVN8lgVwVcJuFylVERHjWfgARy1kns0UzUWaekdNDvxIlyC86fyGJ5WwKwrFZi7urUuN85tpOtZ2CpqqjSt4HIG0UIQs0qtGk-uE7Co4BwAIqAWTESYEzYjR0r1yu2ujm-ltb8IPlEQLrchm2aPsYKucrL393_5SXfNY-jz0dRmfxtbAClnZ2_C5Q7DpqwZ6NYeSRyEIw","refresh_token":"23BwAn3zV49bT2YplnANFRZKqCtH7ZvxzouLxV8YEPy4P","id_token":"eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IlQ4dGNDTmZ4ZUdRWkc5U21yWTFGZCJ9.eyJnaXZlbl9uYW1lIjoiQmhhcmFuaSIsImZhbWlseV9uYW1lIjoiVGhhcmFuIiwibmlja25hbWUiOiJiaGFyYW5pdGhhcmFuNjk1IiwibmFtZSI6IkJoYXJhbmkgVGhhcmFuIiwicGljdHVyZSI6Imh0dHBzOi8vbGgzLmdvb2dsZXVzZXJjb250ZW50LmNvbS9hL0FDZzhvY0p1d3lha0V6d0cycVIwZnh1a0FPYXFCdG1KVmpFRGVPX0NvalJZem1qbmd5eE9jUT1zOTYtYyIsInVwZGF0ZWRfYXQiOiIyMDI1LTAyLTI4VDEyOjUxOjU2LjY5MVoiLCJlbWFpbCI6ImJoYXJhbml0aGFyYW42OTVAZ21haWwuY29tIiwiZW1haWxfdmVyaWZpZWQiOnRydWUsImlzcyI6Imh0dHBzOi8vbG9vcGhvbGUuZXUuYXV0aDAuY29tLyIsImF1ZCI6IjlvY25TQW5mSlNiNkM1MndhTDh4Y1BpZENrUmhVd0JzIiwic3ViIjoiZ29vZ2xlLW9hdXRoMnwxMTI3OTQ1NzA5Mjg0MDIxODQzOTkiLCJpYXQiOjE3NDA3NDcxMjAsImV4cCI6MTc0MDc4MzEyMH0.D-8iAgFTMTOsHLOQisZtO-qfAj0XGWQfH11X3l6I3RP9EMB8VD4_5iaVjE_LAUpSHAZaJserErrlXPXaQYDsbujREvcjgJdOzt5vMD_gisy1y2u7CJ0iFk1yFvAyjyjvDsHlp6IlSPPqVU7uYKopcBCVCKCT1AbPiSx52BG6cZgWtO9JoxphlvuS0JV0H27sU7M7FXSSxEQfUjUcslE-wn7MI-4lT45bR0cF6c1kRS7nGe5SsttzajMCl1SJj3LArQEcKCwOs-IzT3lygtUbruy3pwmwdED8C_dd9UiaX-fX7BkdsDe0Xt5l0lWXn_eqNNrVmiNj6AOdy6ys28CKHA

          if [[ -z "$ACCESS_TOKEN" ]]; then
            echo "‚ùå Failed to retrieve Loophole authentication token."
            exit 1
          fi

          echo "‚úÖ Loophole authenticated successfully!"

      - name: Start Loophole tunnels
        run: |
          nohup loophole http ${{ env.CHAT_SERVICE_PORT }} --name backend > backend_loophole.log 2>&1 &
          nohup loophole http ${{ env.FRONTEND_PORT }} --name frontend > frontend_loophole.log 2>&1 &
          sleep 10  # Give Loophole time to start

          # Fetch public Loophole URLs
          BACKEND_URL=$(grep -oP 'https://.*' backend_loophole.log | head -n 1)
          FRONTEND_URL=$(grep -oP 'https://.*' frontend_loophole.log | head -n 1)

          if [[ -z "$BACKEND_URL" || -z "$FRONTEND_URL" ]]; then
            echo "‚ùå Failed to retrieve Loophole URLs."
            cat backend_loophole.log frontend_loophole.log
            exit 1
          fi

          echo "$BACKEND_URL" > backend_loophole.txt
          echo "$FRONTEND_URL" > frontend_loophole.txt

          echo "‚úÖ Loophole tunnels started successfully!"
          echo "üîó Backend: $BACKEND_URL"
          echo "üîó Frontend: $FRONTEND_URL"

      - name: Refresh Loophole links every 1 hour 55 minutes
        run: |
          for i in {1..3}; do  # Refresh max 3 times
            echo "‚è≥ Waiting for 1 hour 55 minutes before refreshing Loophole tunnels..."
            sleep 50  # 1 hour 55 minutes

            echo "üîÑ Restarting Loophole tunnels..."

            # Stop any running Loophole instances
            pkill -f "loophole" || echo "No existing Loophole process found."

            # Restart tunnels
            echo "üöÄ Starting Loophole tunnels..."
            nohup loophole http ${{ env.CHAT_SERVICE_PORT }} --hostname backend-tunnel.loophole.site > backend_loophole.log 2>&1 &
            nohup loophole http ${{ env.FRONTEND_PORT }} --hostname frontend-tunnel.loophole.site > frontend_loophole.log 2>&1 &

            sleep 10  # Give Loophole time to restart

            BACKEND_URL="https://backend-tunnel.loophole.site"
            FRONTEND_URL="https://frontend-tunnel.loophole.site"

            echo "$BACKEND_URL" > backend_loophole.txt
            echo "$FRONTEND_URL" > frontend_loophole.txt

            echo "‚úÖ Refreshed Loophole URLs"
            echo "üîó Backend: $BACKEND_URL"
            echo "üîó Frontend: $FRONTEND_URL"
          done