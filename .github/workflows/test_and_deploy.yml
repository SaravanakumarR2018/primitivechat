name: Deploy and Test

on:
  push:
    branches:
      - "**"  # Trigger on all branches
  pull_request:
    branches:
      - "**"  # Trigger on PR creation
  workflow_dispatch:
    inputs:
      branch:
        description: "Branch to deploy"
        required: false
        default: "main"

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 360  # 6-hour max execution time

    env:
      CHAT_SERVICE_PORT: 8000
      FRONTEND_PORT: 3000

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          ref: ${{ github.event.inputs.branch || github.head_ref || github.ref_name }}

      # Step 2: Set up SSH for GitHub
      - name: Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan github.com >> ~/.ssh/known_hosts

      # Step 3: Clone the private repository using SSH
      - name: Clone the env repo using SSH
        run: |
          git clone git@github.com:SaravanakumarR2018/primitivechatenv.git env_repo
          ls -la env_repo

      # Step 4: Copy the .env file
      - name: Copy .env file
        run: |
          cp env_repo/.env.local src/frontend/.env.local
          echo "âœ… .env.local copied to src/frontend"

      # Step 5: Install Docker Compose
      - name: Install Docker Compose
        run: |
          sudo apt-get update
          sudo apt-get install -y docker-compose

      # Step 6: Load environment variables from .env file
      - name: Load .env and verify
        working-directory: src/backend
        run: |
          echo "Loading .env file..."
          if [ ! -f .env ]; then
            echo "Error: .env file not found in $(pwd)"
            exit 1
          fi
          # Export all variables from .env to GitHub Actions environment and print them
          while IFS= read -r line || [ -n "$line" ]; do
            [[ "$line" =~ ^#.*$ || -z "$line" ]] && continue  # Skip comments and empty lines
            key=$(echo "$line" | cut -d'=' -f1)
            value=$(echo "$line" | cut -d'=' -f2-)
            echo "$key=$value" >> $GITHUB_ENV
            echo "Exported: $key=$value"
          done < .env
          echo "All environment variables have been loaded and exported."

      # Step 7: Build Docker image
      - name: Build Docker image
        working-directory: src/backend  # Specify working directory here
        env:
          PROJECT_ROOT: ${{ github.workspace }}
        run: |
          echo "Building Docker image chat_service_image"
          docker build -t chat_service_image:latest -f ${PROJECT_ROOT}/build/chat_service_docker/Dockerfile ${PROJECT_ROOT} || {
            echo "Docker build failed. Exiting..."
            exit 1
          }
          echo "Docker image chat_service_image built successfully."

      # Step 8: Run Docker Compose
      - name: Run docker-compose up
        working-directory: src/backend  # Specify working directory here
        env:
          PROJECT_ROOT: ${{ github.workspace }}
        run: docker-compose up -d

      - name: Clone Private Repo
        run: |
          git clone git@github.com:SaravanakumarR2018/primitivechatenv.git private-repo

      - name: List contents of private-repo for debugging
        run: |
          ls -la private-repo

      - name: Verify .env.local file
        run: |
          if [ -f private-repo/.env.local ]; then
            echo ".env.local file exists in private-repo"
          else
            echo ".env.local file does not exist in private-repo"
            exit 1
          fi

      - name: Move contents to src/frontend
        run: |
          cp -r private-repo/. src/frontend/

      - name: Verify .env.local file
        run: |
          if [ -f src/frontend/.env.local ]; then
            echo ".env.local file exists in src/frontend"
          else
            echo ".env.local file does not exist in src/frontend"
            exit 1
          fi

      - name: Install dependencies
        run: |
          cd src/frontend
          npm install

      - name: Build the project
        run: |
          cd src/frontend
          npm run build

      - name: Start Next.js server
        run: |
          cd src/frontend
          npm start &
          sleep 10

      - name: Wait for server to be up
        run: |
          for i in {1..18}; do
            if nc -zv localhost 3000; then
              echo "Server is listening on port 3000"
              exit 0
            else
              echo "Waiting for server to be up..."
              sleep 10
            fi
          done
          echo "Server did not start within 3 minutes"
          exit 1

      - name: Wait for Services to be Ready
        run: |
          timeout 120 bash -c '
            until curl -sSf http://localhost:${{ env.CHAT_SERVICE_PORT }} && curl -sSf http://localhost:${{ env.FRONTEND_PORT }}; 
            do 
              sleep 5; 
            done
          ' || { echo "âŒ Services did not start in time."; exit 1; }
          echo "âœ… Services are up and running."

      - name: Install Loophole
        run: |
          curl -fsSL https://github.com/loophole/cli/releases/latest/download/install.sh | sh
          loophole -v  # Verify installation

      - name: Authenticate Loophole
        run: |
          if [ -z "${{ secrets.LOOPHOLE_AUTH_TOKEN }}" ]; then
            echo "âŒ LOOPHOLE_AUTH_TOKEN is missing!"
            exit 1
          else
            echo "âœ… Authenticating with Loophole..."
            loophole auth ${{ secrets.LOOPHOLE_AUTH_TOKEN }}
          fi

      - name: Start Loophole Tunnels
        run: |
          echo "ðŸš€ Starting Loophole tunnels..."

          # Start backend tunnel in the background
          nohup loophole http ${{ env.CHAT_SERVICE_PORT }} --hostname backend-tunnel.loophole.site > backend_loophole.log 2>&1 &

          # Start frontend tunnel in the background
          nohup loophole http ${{ env.FRONTEND_PORT }} --hostname frontend-tunnel.loophole.site > frontend_loophole.log 2>&1 &

          sleep 10  # Wait for tunnels to start

      - name: Fetch Loophole URLs
        run: |
          BACKEND_URL="https://backend-tunnel.loophole.site"
          FRONTEND_URL="https://frontend-tunnel.loophole.site"

          echo "$BACKEND_URL" > backend_loophole.txt
          echo "$FRONTEND_URL" > frontend_loophole.txt

          echo "âœ… Loophole tunnels started successfully!"
          echo "ðŸ”— Backend: $BACKEND_URL"
          echo "ðŸ”— Frontend: $FRONTEND_URL"

      - name: Refresh Loophole links every 1 hour 55 minutes
        run: |
          for i in {1..3}; do  # Refresh max 3 times
            echo "â³ Waiting for 1 hour 55 minutes before refreshing Loophole tunnels..."
            sleep 50  # 1 hour 55 minutes

            echo "ðŸ”„ Restarting Loophole tunnels..."

            # Stop any running Loophole instances
            pkill -f "loophole" || echo "No existing Loophole process found."

            # Restart tunnels
            echo "ðŸš€ Starting Loophole tunnels..."
            nohup loophole http ${{ env.CHAT_SERVICE_PORT }} --hostname backend-tunnel.loophole.site > backend_loophole.log 2>&1 &
            nohup loophole http ${{ env.FRONTEND_PORT }} --hostname frontend-tunnel.loophole.site > frontend_loophole.log 2>&1 &

            sleep 10  # Give Loophole time to restart

            BACKEND_URL="https://backend-tunnel.loophole.site"
            FRONTEND_URL="https://frontend-tunnel.loophole.site"

            echo "$BACKEND_URL" > backend_loophole.txt
            echo "$FRONTEND_URL" > frontend_loophole.txt

            echo "âœ… Refreshed Loophole URLs"
            echo "ðŸ”— Backend: $BACKEND_URL"
            echo "ðŸ”— Frontend: $FRONTEND_URL"
          done